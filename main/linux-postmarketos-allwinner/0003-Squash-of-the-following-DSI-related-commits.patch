From 694aed089b4f36d504ea4609919b61151380befb Mon Sep 17 00:00:00 2001
From: Vasily Khoruzhick <anarsoul@gmail.com>
Date: Tue, 24 Jul 2018 10:16:56 -0700
Subject: [PATCH 3/3] Squash of the following DSI-related commits:

* A64 DSI WIP
* Pine64 panel WIP
* A64 DSI CCU WIP
* pinebook bl WIP
* A64 DSI DTS wip
* ccu wip
* mipi dsi irq wip
* mipi dsi: don't hardcode tcoon_div
* working DSI
---
 .../dts/allwinner/sun50i-a64-pine64-plus.dts  |  45 +++++
 .../dts/allwinner/sun50i-a64-pinebook.dts     |  10 +
 .../allwinner/sun50i-a64-sopine-baseboard.dts |  40 ++++
 arch/arm64/boot/dts/allwinner/sun50i-a64.dtsi |  43 +++++
 drivers/clk/sunxi-ng/ccu-sun50i-a64.c         |   6 +-
 drivers/gpu/drm/sun4i/sun4i_dotclock.c        |  15 +-
 drivers/gpu/drm/sun4i/sun4i_tcon.c            |  49 ++++-
 drivers/gpu/drm/sun4i/sun4i_tcon.h            |   4 +
 drivers/gpu/drm/sun4i/sun6i_mipi_dphy.c       |  43 +++--
 drivers/gpu/drm/sun4i/sun6i_mipi_dsi.c        | 177 ++++++++++++++++--
 drivers/gpu/drm/sun4i/sun6i_mipi_dsi.h        |  49 +++--
 11 files changed, 415 insertions(+), 66 deletions(-)

diff --git a/arch/arm64/boot/dts/allwinner/sun50i-a64-pine64-plus.dts b/arch/arm64/boot/dts/allwinner/sun50i-a64-pine64-plus.dts
index ed715426fffc..629b7c92d903 100644
--- a/arch/arm64/boot/dts/allwinner/sun50i-a64-pine64-plus.dts
+++ b/arch/arm64/boot/dts/allwinner/sun50i-a64-pine64-plus.dts
@@ -41,14 +41,53 @@
  */
 
 #include "sun50i-a64-pine64.dts"
+#include <dt-bindings/pwm/pwm.h>
 
 / {
 	model = "Pine64+";
 	compatible = "pine64,pine64-plus", "allwinner,sun50i-a64";
 
+	pwm_bl: backlight {
+		compatible = "pwm-backlight";
+		pwms = <&r_pwm 0 50000 PWM_POLARITY_INVERTED>;
+		brightness-levels = <1 2 4 8 16 32 64 128 255>;
+		default-brightness-level = <8>;
+		enable-gpios = <&pio 7 10 GPIO_ACTIVE_HIGH>; /* PH10 */
+	};
+
+
 	/* TODO: Camera, touchscreen, etc. */
 };
 
+&de {
+	status = "okay";
+};
+
+&mixer0 {
+	status = "okay";
+};
+
+&tcon0 {
+	status = "okay";
+};
+
+&dphy {
+	status = "okay";
+};
+
+&dsi {
+	status = "okay";
+
+	panel@0 {
+		compatible = "feiyang,fy07024di26a30d", "simple-panel";
+		reg = <0>;
+		reset-gpios = <&pio 3 24 GPIO_ACTIVE_HIGH>; /* PD24 */
+		backlight = <&pwm_bl>;
+		avdd-supply = <&reg_dc1sw>;
+		dvdd-supply = <&reg_dldo2>;
+	};
+};
+
 &emac {
 	pinctrl-names = "default";
 	pinctrl-0 = <&rgmii_pins>;
@@ -63,3 +102,9 @@
 		reg = <1>;
 	};
 };
+
+&r_pwm {
+	pinctrl-names = "default";
+	pinctrl-0 = <&r_pwm_pin>;
+	status = "okay";
+};
diff --git a/arch/arm64/boot/dts/allwinner/sun50i-a64-pinebook.dts b/arch/arm64/boot/dts/allwinner/sun50i-a64-pinebook.dts
index cdd4d6322aff..95bcedc13d27 100644
--- a/arch/arm64/boot/dts/allwinner/sun50i-a64-pinebook.dts
+++ b/arch/arm64/boot/dts/allwinner/sun50i-a64-pinebook.dts
@@ -22,12 +22,22 @@
 		ethernet0 = &rtl8723cs;
 	};
 
+	vdd_bl: regulator@0 {
+		compatible = "regulator-fixed";
+		regulator-name = "bl-3v3";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		gpio = <&pio 7 6 GPIO_ACTIVE_HIGH>; /* PH6 */
+		enable-active-high;
+	};
+
 	backlight: backlight {
 		compatible = "pwm-backlight";
 		pwms = <&pwm 0 50000 0>;
 		brightness-levels = <0 5 10 15 20 30 40 55 70 85 100>;
 		default-brightness-level = <2>;
 		enable-gpios = <&pio 3 23 GPIO_ACTIVE_HIGH>; /* PD23 */
+		power-supply = <&vdd_bl>;
 	};
 
 	chosen {
diff --git a/arch/arm64/boot/dts/allwinner/sun50i-a64-sopine-baseboard.dts b/arch/arm64/boot/dts/allwinner/sun50i-a64-sopine-baseboard.dts
index d43969a20267..cca4b53f3955 100644
--- a/arch/arm64/boot/dts/allwinner/sun50i-a64-sopine-baseboard.dts
+++ b/arch/arm64/boot/dts/allwinner/sun50i-a64-sopine-baseboard.dts
@@ -46,6 +46,7 @@
 /dts-v1/;
 
 #include "sun50i-a64-sopine.dtsi"
+#include <dt-bindings/pwm/pwm.h>
 
 / {
 	model = "SoPine with baseboard";
@@ -78,6 +79,14 @@
 		regulator-min-microvolt = <1800000>;
 		regulator-max-microvolt = <1800000>;
 	};
+
+	pwm_bl: backlight {
+		compatible = "pwm-backlight";
+		pwms = <&r_pwm 0 50000 PWM_POLARITY_INVERTED>;
+		brightness-levels = <1 2 4 8 16 32 64 128 255>;
+		default-brightness-level = <8>;
+		enable-gpios = <&pio 7 10 GPIO_ACTIVE_HIGH>; /* PH10 */
+	};
 };
 
 &ac_power_supply {
@@ -108,6 +117,18 @@
 	status = "okay";
 };
 
+&mixer0 {
+	status = "okay";
+};
+
+&tcon0 {
+	status = "okay";
+};
+
+&dphy {
+	status = "okay";
+};
+
 &ehci0 {
 	status = "okay";
 };
@@ -116,6 +137,19 @@
 	status = "okay";
 };
 
+&dsi {
+	status = "okay";
+
+	panel@0 {
+		compatible = "feiyang,fy07024di26a30d", "simple-panel";
+		reg = <0>;
+		reset-gpios = <&pio 3 24 GPIO_ACTIVE_HIGH>; /* PD24 */
+		backlight = <&pwm_bl>;
+		avdd-supply = <&reg_dc1sw>;
+		dvdd-supply = <&reg_dldo2>;
+	};
+};
+
 &emac {
 	pinctrl-names = "default";
 	pinctrl-0 = <&rgmii_pins>;
@@ -252,3 +286,9 @@
 &usbphy {
 	status = "okay";
 };
+
+&r_pwm {
+	pinctrl-names = "default";
+	pinctrl-0 = <&r_pwm_pin>;
+	status = "okay";
+};
diff --git a/arch/arm64/boot/dts/allwinner/sun50i-a64.dtsi b/arch/arm64/boot/dts/allwinner/sun50i-a64.dtsi
index 5e9e34d873b8..241118ba954a 100644
--- a/arch/arm64/boot/dts/allwinner/sun50i-a64.dtsi
+++ b/arch/arm64/boot/dts/allwinner/sun50i-a64.dtsi
@@ -471,6 +471,11 @@
 					#address-cells = <1>;
 					#size-cells = <0>;
 					reg = <1>;
+
+					tcon0_out_dsi: endpoint@1 {
+						reg = <1>;
+						remote-endpoint = <&dsi_in_tcon0>;
+					};
 				};
 			};
 		};
@@ -873,6 +878,44 @@
 			#thermal-sensor-cells = <1>;
 		};
 
+		dsi: dsi@1ca0000 {
+			compatible = "allwinner,sun50i-a64-mipi-dsi";
+			reg = <0x01ca0000 0x1000>;
+			interrupts = <GIC_SPI 89 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_MIPI_DSI>,
+				 <&ccu CLK_DSI_DPHY>;
+			clock-names = "bus", "mod";
+			resets = <&ccu RST_BUS_MIPI_DSI>;
+			phys = <&dphy>;
+			phy-names = "dphy";
+			status = "disabled";
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				port@0 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <0>;
+
+					dsi_in_tcon0: endpoint {
+						remote-endpoint = <&tcon0_out_dsi>;
+					};
+				};
+			};
+		};
+
+		dphy: d-phy@1ca1000 {
+			compatible = "allwinner,sun50i-a64-mipi-dphy";
+			reg = <0x01ca1000 0x1000>;
+			clocks = <&ccu CLK_BUS_MIPI_DSI>;
+			clock-names = "bus";
+			resets = <&ccu RST_BUS_MIPI_DSI>;
+			status = "disabled";
+			#phy-cells = <0>;
+		};
+
 		uart0: serial@1c28000 {
 			compatible = "snps,dw-apb-uart";
 			reg = <0x01c28000 0x400>;
diff --git a/drivers/clk/sunxi-ng/ccu-sun50i-a64.c b/drivers/clk/sunxi-ng/ccu-sun50i-a64.c
index a637e62ae1c4..6d483c7c0d12 100644
--- a/drivers/clk/sunxi-ng/ccu-sun50i-a64.c
+++ b/drivers/clk/sunxi-ng/ccu-sun50i-a64.c
@@ -524,8 +524,8 @@ static const char * const de_parents[] = { "pll-periph0-2x", "pll-de" };
 static SUNXI_CCU_M_WITH_MUX_GATE(de_clk, "de", de_parents,
 				 0x104, 0, 4, 24, 3, BIT(31), 0);
 
-static const char * const tcon0_parents[] = { "pll-mipi", "pll-video0-2x" };
-static const u8 tcon0_table[] = { 0, 2, };
+static const char * const tcon0_parents[] = { "pll-mipi", "pll-video-2x" };
+static const u8 tcon0_table[] = { 0,  };
 static SUNXI_CCU_MUX_TABLE_WITH_GATE(tcon0_clk, "tcon0", tcon0_parents,
 				     tcon0_table, 0x118, 24, 3, BIT(31),
 				     CLK_SET_RATE_PARENT);
@@ -588,7 +588,7 @@ static const char * const dsi_dphy_parents[] = { "pll-video0", "pll-periph0" };
 static const u8 dsi_dphy_table[] = { 0, 2, };
 static SUNXI_CCU_M_WITH_MUX_TABLE_GATE(dsi_dphy_clk, "dsi-dphy",
 				       dsi_dphy_parents, dsi_dphy_table,
-				       0x168, 0, 4, 8, 2, BIT(31), CLK_SET_RATE_PARENT);
+				       0x168, 0, 4, 8, 2, BIT(15), CLK_SET_RATE_PARENT);
 
 static SUNXI_CCU_M_WITH_GATE(gpu_clk, "gpu", "pll-gpu",
 			     0x1a0, 0, 3, BIT(31), CLK_SET_RATE_PARENT);
diff --git a/drivers/gpu/drm/sun4i/sun4i_dotclock.c b/drivers/gpu/drm/sun4i/sun4i_dotclock.c
index 2a15f2f9271e..e6058848a403 100644
--- a/drivers/gpu/drm/sun4i/sun4i_dotclock.c
+++ b/drivers/gpu/drm/sun4i/sun4i_dotclock.c
@@ -32,7 +32,10 @@ static void sun4i_dclk_disable(struct clk_hw *hw)
 	struct sun4i_dclk *dclk = hw_to_dclk(hw);
 
 	regmap_update_bits(dclk->regmap, SUN4I_TCON0_DCLK_REG,
-			   BIT(SUN4I_TCON0_DCLK_GATE_BIT), 0);
+			   BIT(SUN4I_TCON0_DCLK_GATE_BIT) |
+			   BIT(SUN4I_TCON0_DCLK_GATE2_BIT) |
+			   BIT(SUN4I_TCON0_DCLK_GATE3_BIT) |
+			   BIT(SUN4I_TCON0_DCLK_GATE4_BIT), 0);
 }
 
 static int sun4i_dclk_enable(struct clk_hw *hw)
@@ -40,8 +43,14 @@ static int sun4i_dclk_enable(struct clk_hw *hw)
 	struct sun4i_dclk *dclk = hw_to_dclk(hw);
 
 	return regmap_update_bits(dclk->regmap, SUN4I_TCON0_DCLK_REG,
-				  BIT(SUN4I_TCON0_DCLK_GATE_BIT),
-				  BIT(SUN4I_TCON0_DCLK_GATE_BIT));
+			   BIT(SUN4I_TCON0_DCLK_GATE_BIT) |
+			   BIT(SUN4I_TCON0_DCLK_GATE2_BIT) |
+			   BIT(SUN4I_TCON0_DCLK_GATE3_BIT) |
+			   BIT(SUN4I_TCON0_DCLK_GATE4_BIT),
+			   BIT(SUN4I_TCON0_DCLK_GATE_BIT) |
+			   BIT(SUN4I_TCON0_DCLK_GATE2_BIT) |
+			   BIT(SUN4I_TCON0_DCLK_GATE3_BIT) |
+			   BIT(SUN4I_TCON0_DCLK_GATE4_BIT));
 }
 
 static int sun4i_dclk_is_enabled(struct clk_hw *hw)
diff --git a/drivers/gpu/drm/sun4i/sun4i_tcon.c b/drivers/gpu/drm/sun4i/sun4i_tcon.c
index 8c8e39ab9a76..76421711596c 100644
--- a/drivers/gpu/drm/sun4i/sun4i_tcon.c
+++ b/drivers/gpu/drm/sun4i/sun4i_tcon.c
@@ -271,6 +271,7 @@ static void sun4i_tcon0_mode_set_common(struct sun4i_tcon *tcon,
 {
 	/* Configure the dot clock */
 	clk_set_rate(tcon->dclk, mode->crtc_clock * 1000);
+	pr_info("%s, rate: %d\n", __func__, mode->crtc_clock);
 
 	/* Set the resolution */
 	regmap_write(tcon->regs, SUN4I_TCON0_BASIC0_REG,
@@ -340,8 +341,9 @@ static void sun4i_tcon0_mode_set_cpu(struct sun4i_tcon *tcon,
 	u8 lanes = device->lanes;
 	u32 block_space, start_delay;
 	u32 tcon_div;
+	u32 dsi_clk;
 
-	tcon->dclk_min_div = 4;
+	tcon->dclk_min_div = 6;
 	tcon->dclk_max_div = 127;
 
 	sun4i_tcon0_mode_set_common(tcon, mode);
@@ -349,6 +351,18 @@ static void sun4i_tcon0_mode_set_cpu(struct sun4i_tcon *tcon,
 	/* Set dithering if needed */
 	sun4i_tcon0_mode_set_dithering(tcon, sun4i_tcon_get_connector(encoder));
 
+#if 0
+	dsi_clk = mode->crtc_clock * 1000 * 6;
+	dsi_clk /= 4;
+	/* Configure the dot clock */
+	clk_set_rate(tcon->dclk, dsi_clk);
+
+	/* Set the resolution */
+	regmap_write(tcon->regs, SUN4I_TCON0_BASIC0_REG,
+		     SUN4I_TCON0_BASIC0_X(mode->crtc_hdisplay) |
+		     SUN4I_TCON0_BASIC0_Y(mode->crtc_vdisplay));
+#endif
+
 	regmap_update_bits(tcon->regs, SUN4I_TCON0_CTL_REG,
 			   SUN4I_TCON0_CTL_IF_MASK,
 			   SUN4I_TCON0_CTL_IF_8080);
@@ -372,6 +386,7 @@ static void sun4i_tcon0_mode_set_cpu(struct sun4i_tcon *tcon,
 	tcon_div &= GENMASK(6, 0);
 	block_space = mode->htotal * bpp / (tcon_div * lanes);
 	block_space -= mode->hdisplay + 40;
+	block_space += 1;
 
 	regmap_write(tcon->regs, SUN4I_TCON0_CPU_TRI0_REG,
 		     SUN4I_TCON0_CPU_TRI0_BLOCK_SPACE(block_space) |
@@ -392,8 +407,9 @@ static void sun4i_tcon0_mode_set_cpu(struct sun4i_tcon *tcon,
 	 * the display clock * 15, but uses an hardcoded 3000...
 	 */
 	regmap_write(tcon->regs, SUN4I_TCON_SAFE_PERIOD_REG,
-		     SUN4I_TCON_SAFE_PERIOD_NUM(3000) |
-		     SUN4I_TCON_SAFE_PERIOD_MODE(3));
+		     0x03390023);
+		     //SUN4I_TCON_SAFE_PERIOD_NUM(3000) |
+		     //SUN4I_TCON_SAFE_PERIOD_MODE(3));
 
 	/* Enable the output on the pins */
 	regmap_write(tcon->regs, SUN4I_TCON0_IO_TRI_REG,
@@ -714,12 +730,23 @@ static void sun4i_tcon_finish_page_flip(struct drm_device *dev,
 	spin_unlock_irqrestore(&dev->event_lock, flags);
 }
 
-static irqreturn_t sun4i_tcon_handler(int irq, void *private)
+void sun4i_tcon_handle_vblank(struct sun4i_tcon *tcon)
 {
-	struct sun4i_tcon *tcon = private;
 	struct drm_device *drm = tcon->drm;
 	struct sun4i_crtc *scrtc = tcon->crtc;
 	struct sunxi_engine *engine = scrtc->engine;
+
+	drm_crtc_handle_vblank(&scrtc->crtc);
+	sun4i_tcon_finish_page_flip(drm, scrtc);
+
+	if (engine->ops->vblank_quirk)
+		engine->ops->vblank_quirk(engine);
+}
+EXPORT_SYMBOL(sun4i_tcon_handle_vblank);
+
+static irqreturn_t sun4i_tcon_handler(int irq, void *private)
+{
+	struct sun4i_tcon *tcon = private;
 	unsigned int status;
 
 	regmap_read(tcon->regs, SUN4I_TCON_GINT0_REG, &status);
@@ -729,9 +756,6 @@ static irqreturn_t sun4i_tcon_handler(int irq, void *private)
 			SUN4I_TCON_GINT0_TCON0_TRI_FINISH_INT)))
 		return IRQ_NONE;
 
-	drm_crtc_handle_vblank(&scrtc->crtc);
-	sun4i_tcon_finish_page_flip(drm, scrtc);
-
 	/* Acknowledge the interrupt */
 	regmap_update_bits(tcon->regs, SUN4I_TCON_GINT0_REG,
 			   SUN4I_TCON_GINT0_VBLANK_INT(0) |
@@ -739,8 +763,7 @@ static irqreturn_t sun4i_tcon_handler(int irq, void *private)
 			   SUN4I_TCON_GINT0_TCON0_TRI_FINISH_INT,
 			   0);
 
-	if (engine->ops->vblank_quirk)
-		engine->ops->vblank_quirk(engine);
+	sun4i_tcon_handle_vblank(tcon);
 
 	return IRQ_HANDLED;
 }
@@ -1257,6 +1280,12 @@ static int sun4i_tcon_bind(struct device *dev, struct device *master,
 				   SUN4I_TCON1_CTL_SRC_SEL_MASK,
 				   tcon->id);
 	}
+#if 0
+	/* Test pattern - white */
+	regmap_update_bits(tcon->regs, SUN4I_TCON0_CTL_REG,
+			   SUN4I_TCON0_CTL_SRC_SEL_MASK,
+			   5);
+#endif
 
 	list_add_tail(&tcon->list, &drv->tcon_list);
 
diff --git a/drivers/gpu/drm/sun4i/sun4i_tcon.h b/drivers/gpu/drm/sun4i/sun4i_tcon.h
index 3d492c8be1fc..e90250e4bbfd 100644
--- a/drivers/gpu/drm/sun4i/sun4i_tcon.h
+++ b/drivers/gpu/drm/sun4i/sun4i_tcon.h
@@ -63,6 +63,9 @@
 
 #define SUN4I_TCON0_DCLK_REG			0x44
 #define SUN4I_TCON0_DCLK_GATE_BIT			(31)
+#define SUN4I_TCON0_DCLK_GATE2_BIT			(30)
+#define SUN4I_TCON0_DCLK_GATE3_BIT			(29)
+#define SUN4I_TCON0_DCLK_GATE4_BIT			(28)
 #define SUN4I_TCON0_DCLK_DIV_SHIFT			(0)
 #define SUN4I_TCON0_DCLK_DIV_WIDTH			(7)
 
@@ -279,6 +282,7 @@ void sun4i_tcon_mode_set(struct sun4i_tcon *tcon,
 			 const struct drm_display_mode *mode);
 void sun4i_tcon_set_status(struct sun4i_tcon *crtc,
 			   const struct drm_encoder *encoder, bool enable);
+void sun4i_tcon_handle_vblank(struct sun4i_tcon *crtc);
 
 extern const struct of_device_id sun4i_tcon_of_table[];
 
diff --git a/drivers/gpu/drm/sun4i/sun6i_mipi_dphy.c b/drivers/gpu/drm/sun4i/sun6i_mipi_dphy.c
index e4d19431fa0e..79f4bd54ac2f 100644
--- a/drivers/gpu/drm/sun4i/sun6i_mipi_dphy.c
+++ b/drivers/gpu/drm/sun4i/sun6i_mipi_dphy.c
@@ -84,8 +84,10 @@
 int sun6i_dphy_init(struct sun6i_dphy *dphy, unsigned int lanes)
 {
 	reset_control_deassert(dphy->reset);
-	clk_prepare_enable(dphy->mod_clk);
-	clk_set_rate_exclusive(dphy->mod_clk, 150000000);
+	if (dphy->quirks->has_mod_clk) {
+		clk_prepare_enable(dphy->mod_clk);
+		clk_set_rate_exclusive(dphy->mod_clk, 150000000);
+	}
 
 	regmap_write(dphy->regs, SUN6I_DPHY_TX_CTL_REG,
 		     SUN6I_DPHY_TX_CTL_HS_TX_CLK_CONT);
@@ -191,8 +193,10 @@ int sun6i_dphy_power_off(struct sun6i_dphy *dphy)
 
 int sun6i_dphy_exit(struct sun6i_dphy *dphy)
 {
-	clk_rate_exclusive_put(dphy->mod_clk);
-	clk_disable_unprepare(dphy->mod_clk);
+	if (dphy->quirks->has_mod_clk) {
+		clk_rate_exclusive_put(dphy->mod_clk);
+		clk_disable_unprepare(dphy->mod_clk);
+	}
 	reset_control_assert(dphy->reset);
 
 	return 0;
@@ -206,8 +210,17 @@ static struct regmap_config sun6i_dphy_regmap_config = {
 	.name		= "mipi-dphy",
 };
 
+static const struct sun6i_dphy_quirks sun6i_a31_quirks = {
+	.has_mod_clk = true,
+};
+
+static const struct sun6i_dphy_quirks sun50i_a64_quirks = {
+	.has_mod_clk = false,
+};
+
 static const struct of_device_id sun6i_dphy_of_table[] = {
-	{ .compatible = "allwinner,sun6i-a31-mipi-dphy" },
+	{ .compatible = "allwinner,sun6i-a31-mipi-dphy", .data = &sun6i_a31_quirks },
+	{ .compatible = "allwinner,sun50i-a64-mipi-dphy", .data = &sun50i_a64_quirks },
 	{ }
 };
 
@@ -216,9 +229,10 @@ int sun6i_dphy_probe(struct sun6i_dsi *dsi, struct device_node *node)
 	struct sun6i_dphy *dphy;
 	struct resource res;
 	void __iomem *regs;
+	const struct of_device_id *id;
 	int ret;
 
-	if (!of_match_node(sun6i_dphy_of_table, node)) {
+	if (!(id = of_match_node(sun6i_dphy_of_table, node))) {
 		dev_err(dsi->dev, "Incompatible D-PHY\n");
 		return -EINVAL;
 	}
@@ -227,6 +241,8 @@ int sun6i_dphy_probe(struct sun6i_dsi *dsi, struct device_node *node)
 	if (!dphy)
 		return -ENOMEM;
 
+	dphy->quirks = id->data;
+
 	ret = of_address_to_resource(node, 0, &res);
 	if (ret) {
 		dev_err(dsi->dev, "phy: Couldn't get our resources\n");
@@ -260,11 +276,13 @@ int sun6i_dphy_probe(struct sun6i_dsi *dsi, struct device_node *node)
 	}
 	regmap_mmio_attach_clk(dphy->regs, dphy->bus_clk);
 
-	dphy->mod_clk = of_clk_get_by_name(node, "mod");
-	if (IS_ERR(dphy->mod_clk)) {
-		dev_err(dsi->dev, "Couldn't get the DPHY mod clock\n");
-		ret = PTR_ERR(dphy->mod_clk);
-		goto err_free_bus;
+	if (dphy->quirks->has_mod_clk) {
+		dphy->mod_clk = of_clk_get_by_name(node, "mod");
+		if (IS_ERR(dphy->mod_clk)) {
+			dev_err(dsi->dev, "Couldn't get the DPHY mod clock\n");
+			ret = PTR_ERR(dphy->mod_clk);
+			goto err_free_bus;
+		}
 	}
 
 	dsi->dphy = dphy;
@@ -284,7 +302,8 @@ int sun6i_dphy_remove(struct sun6i_dsi *dsi)
 	struct sun6i_dphy *dphy = dsi->dphy;
 
 	regmap_mmio_detach_clk(dphy->regs);
-	clk_put(dphy->mod_clk);
+	if (dphy->quirks->has_mod_clk)
+		clk_put(dphy->mod_clk);
 	clk_put(dphy->bus_clk);
 	reset_control_put(dphy->reset);
 
diff --git a/drivers/gpu/drm/sun4i/sun6i_mipi_dsi.c b/drivers/gpu/drm/sun4i/sun6i_mipi_dsi.c
index e3b34a345546..7498e4c6bcf6 100644
--- a/drivers/gpu/drm/sun4i/sun6i_mipi_dsi.c
+++ b/drivers/gpu/drm/sun4i/sun6i_mipi_dsi.c
@@ -10,6 +10,7 @@
 #include <linux/component.h>
 #include <linux/crc-ccitt.h>
 #include <linux/of_address.h>
+#include <linux/of_device.h>
 #include <linux/pm_runtime.h>
 #include <linux/regmap.h>
 #include <linux/reset.h>
@@ -24,6 +25,7 @@
 #include <drm/drm_panel.h>
 
 #include "sun4i_drv.h"
+#include "sun4i_tcon.h"
 #include "sun6i_mipi_dsi.h"
 
 #include <video/mipi_display.h>
@@ -31,7 +33,13 @@
 #define SUN6I_DSI_CTL_REG		0x000
 #define SUN6I_DSI_CTL_EN			BIT(0)
 
+#define SUN6I_DSI_GINT_REG		0x004
+#define SUN6I_DSI_GINT_VIDEO_VBLK_ENABLE	BIT(2)
+#define SUN6I_DSI_GINT_VIDEO_VBLK_INT		BIT(18)
+
 #define SUN6I_DSI_BASIC_CTL_REG		0x00c
+#define SUN6I_DSI_BASIC_CTL_TRAIL_INV(n)	(((n) & 0xf) << 4)
+#define SUN6I_DSI_BASIC_CTL_TRAIL_FILL		BIT(3)
 #define SUN6I_DSI_BASIC_CTL_HBP_DIS		BIT(2)
 #define SUN6I_DSI_BASIC_CTL_HSA_HSE_DIS		BIT(1)
 #define SUN6I_DSI_BASIC_CTL_VIDEO_BURST		BIT(0)
@@ -352,12 +360,20 @@ static void sun6i_dsi_inst_init(struct sun6i_dsi *dsi,
 		     SUN6I_DSI_INST_JUMP_CFG_POINT(DSI_INST_ID_NOP) |
 		     SUN6I_DSI_INST_JUMP_CFG_TO(DSI_INST_ID_HSCEXIT) |
 		     SUN6I_DSI_INST_JUMP_CFG_NUM(1));
+	regmap_write(dsi->regs, SUN6I_DSI_INST_LOOP_SEL_REG, 0x30000002);
 };
 
 static u16 sun6i_dsi_get_video_start_delay(struct sun6i_dsi *dsi,
 					   struct drm_display_mode *mode)
 {
-	return mode->vtotal - (mode->vsync_end - mode->vdisplay) + 1;
+	u32 vfp = mode->vtotal - mode->vdisplay - (mode->vtotal - mode->vsync_start);
+	u32 start_delay = mode->vtotal - vfp + 1;
+	if (start_delay > mode->vtotal)
+		start_delay -= mode->vtotal;
+	if (!start_delay)
+		start_delay = 1;
+	//return mode->vtotal - (mode->vsync_end - mode->vdisplay) + 1;
+	return start_delay;
 }
 
 static void sun6i_dsi_setup_burst(struct sun6i_dsi *dsi,
@@ -366,25 +382,67 @@ static void sun6i_dsi_setup_burst(struct sun6i_dsi *dsi,
 	struct mipi_dsi_device *device = dsi->device;
 	u32 val = 0;
 
-	if ((mode->hsync_end - mode->hdisplay) > 20) {
-		/* Maaaaaagic */
-		u16 drq = (mode->hsync_end - mode->hdisplay) - 20;
+	if (device->mode_flags & MIPI_DSI_MODE_VIDEO_BURST) {
+		unsigned int bpp = mipi_dsi_pixel_format_to_bpp(device->format);
+		u32 line_num, edge0, edge1, sync_point = 40;
+		unsigned long dclk_rate, dclk_parent_rate;
+		u32 tcon_div;
+
+		dclk_rate = clk_get_rate(dsi->tcon->dclk);
+		dclk_parent_rate = clk_get_rate(clk_get_parent(dsi->tcon->dclk));
+		tcon_div = dclk_parent_rate / dclk_rate;
+
+		line_num = mode->htotal * bpp / (8 * device->lanes);
+		edge1 = sync_point + (mode->hdisplay + mode->htotal - mode->hsync_start + 20) * bpp / (8 * device->lanes);
+		edge0 = edge1 + (mode->hdisplay + 40) * tcon_div / 8;
+		if (edge0 > line_num)
+			edge0 = edge0 - line_num;
+		else
+			edge0 = 1;
+		regmap_write(dsi->regs, SUN6I_DSI_BURST_DRQ_REG,
+			     SUN6I_DSI_BURST_DRQ_EDGE1(edge1) |
+			     SUN6I_DSI_BURST_DRQ_EDGE0(edge0));
+		regmap_write(dsi->regs, SUN6I_DSI_TCON_DRQ_REG,
+			     SUN6I_DSI_TCON_DRQ_ENABLE_MODE);
+		regmap_write(dsi->regs, SUN6I_DSI_BURST_LINE_REG,
+			     SUN6I_DSI_BURST_LINE_NUM(line_num) |
+			     SUN6I_DSI_BURST_LINE_SYNC_POINT(sync_point));
+		regmap_read(dsi->regs, SUN6I_DSI_BASIC_CTL_REG, &val);
+		if (device->lanes == 4) {
+			val |= SUN6I_DSI_BASIC_CTL_TRAIL_INV(0xc);
+			val |= SUN6I_DSI_BASIC_CTL_TRAIL_FILL;
+		}
+		val |= SUN6I_DSI_BASIC_CTL_HBP_DIS;
+		val |= SUN6I_DSI_BASIC_CTL_HSA_HSE_DIS;
+		val |= SUN6I_DSI_BASIC_CTL_VIDEO_BURST;
+		regmap_write(dsi->regs, SUN6I_DSI_BASIC_CTL_REG, val);
+	} else {
+		if ((mode->hsync_end - mode->hdisplay) > 20) {
+			/* Maaaaaagic */
+			u16 drq = (mode->hsync_end - mode->hdisplay) - 20;
+
+			drq *= mipi_dsi_pixel_format_to_bpp(device->format);
+			drq /= 32;
 
-		drq *= mipi_dsi_pixel_format_to_bpp(device->format);
-		drq /= 32;
+			val = (SUN6I_DSI_TCON_DRQ_ENABLE_MODE |
+			       SUN6I_DSI_TCON_DRQ_SET(drq));
+		}
 
-		val = (SUN6I_DSI_TCON_DRQ_ENABLE_MODE |
-		       SUN6I_DSI_TCON_DRQ_SET(drq));
+		regmap_write(dsi->regs, SUN6I_DSI_TCON_DRQ_REG, val);
 	}
-
-	regmap_write(dsi->regs, SUN6I_DSI_TCON_DRQ_REG, val);
 }
 
 static void sun6i_dsi_setup_inst_loop(struct sun6i_dsi *dsi,
 				      struct drm_display_mode *mode)
 {
+	struct mipi_dsi_device *device = dsi->device;
 	u16 delay = 50 - 1;
 
+	if (device->mode_flags & MIPI_DSI_MODE_VIDEO_BURST)
+		delay = (mode->htotal - mode->hdisplay) * 150 / ((mode->clock / 1000) * 8) - 50;
+	else
+		delay = 50 - 1;
+
 	regmap_write(dsi->regs, SUN6I_DSI_INST_LOOP_NUM_REG(0),
 		     SUN6I_DSI_INST_LOOP_NUM_N0(50 - 1) |
 		     SUN6I_DSI_INST_LOOP_NUM_N1(delay));
@@ -500,7 +558,8 @@ static void sun6i_dsi_setup_timings(struct sun6i_dsi *dsi,
 	if (WARN_ON(!buffer))
 		return;
 
-	regmap_write(dsi->regs, SUN6I_DSI_BASIC_CTL_REG, 0);
+	/* FIXME */
+	//regmap_write(dsi->regs, SUN6I_DSI_BASIC_CTL_REG, 0);
 
 	regmap_write(dsi->regs, SUN6I_DSI_SYNC_HSS_REG,
 		     sun6i_dsi_build_sync_pkt(MIPI_DSI_H_SYNC_START,
@@ -525,8 +584,8 @@ static void sun6i_dsi_setup_timings(struct sun6i_dsi *dsi,
 	regmap_write(dsi->regs, SUN6I_DSI_BASIC_SIZE0_REG,
 		     SUN6I_DSI_BASIC_SIZE0_VSA(mode->vsync_end -
 					       mode->vsync_start) |
-		     SUN6I_DSI_BASIC_SIZE0_VBP(mode->vsync_start -
-					       mode->vdisplay));
+		     SUN6I_DSI_BASIC_SIZE0_VBP(mode->vtotal -
+					       mode->vsync_end));
 
 	regmap_write(dsi->regs, SUN6I_DSI_BASIC_SIZE1_REG,
 		     SUN6I_DSI_BASIC_SIZE1_VACT(mode->vdisplay) |
@@ -660,6 +719,9 @@ static void sun6i_dsi_encoder_enable(struct drm_encoder *encoder)
 	udelay(1000);
 
 	sun6i_dsi_start(dsi, DSI_START_HSD);
+
+	regmap_write(dsi->regs, SUN6I_DSI_GINT_REG,
+		     SUN6I_DSI_GINT_VIDEO_VBLK_ENABLE);
 }
 
 static void sun6i_dsi_encoder_disable(struct drm_encoder *encoder)
@@ -668,6 +730,8 @@ static void sun6i_dsi_encoder_disable(struct drm_encoder *encoder)
 
 	DRM_DEBUG_DRIVER("Disabling DSI output\n");
 
+	regmap_write(dsi->regs, SUN6I_DSI_GINT_REG, 0);
+
 	if (!IS_ERR(dsi->panel)) {
 		drm_panel_disable(dsi->panel);
 		drm_panel_unprepare(dsi->panel);
@@ -890,6 +954,50 @@ static ssize_t sun6i_dsi_transfer(struct mipi_dsi_host *host,
 	return ret;
 }
 
+static irqreturn_t sun6i_dsi_handler(int irq, void *private)
+{
+	struct sun6i_dsi *dsi = private;
+	struct sun4i_tcon *tcon = dsi->tcon;
+	unsigned int status;
+	static int cnt;
+
+	regmap_read(dsi->regs, SUN6I_DSI_GINT_REG, &status);
+
+	cnt++;
+	if (!(cnt % 60))
+		pr_info("%s %.8x\n", __func__, status);
+	if (!(status & SUN6I_DSI_GINT_VIDEO_VBLK_INT))
+		return IRQ_NONE;
+
+	regmap_update_bits(dsi->regs, SUN6I_DSI_GINT_REG,
+			   SUN6I_DSI_GINT_VIDEO_VBLK_INT,
+			   SUN6I_DSI_GINT_VIDEO_VBLK_INT);
+
+	sun4i_tcon_handle_vblank(tcon);
+
+	return IRQ_HANDLED;
+}
+static int sun6i_dsi_init_irq(struct device *dev, struct sun6i_dsi *dsi)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	int irq, ret;
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		dev_err(dev, "Couldn't retrieve the DSI interrupt\n");
+		return irq;
+	}
+
+	ret = devm_request_irq(dev, irq, sun6i_dsi_handler, 0,
+			       dev_name(dev), dsi);
+	if (ret) {
+		dev_err(dev, "Couldn't request the IRQ\n");
+		return ret;
+	}
+
+	return 0;
+}
+
 static const struct mipi_dsi_host_ops sun6i_dsi_host_ops = {
 	.attach		= sun6i_dsi_attach,
 	.detach		= sun6i_dsi_detach,
@@ -910,6 +1018,7 @@ static int sun6i_dsi_bind(struct device *dev, struct device *master,
 	struct drm_device *drm = data;
 	struct sun4i_drv *drv = drm->dev_private;
 	struct sun6i_dsi *dsi = dev_get_drvdata(dev);
+	struct sun4i_tcon *tcon;
 	int ret;
 
 	if (!dsi->panel)
@@ -917,6 +1026,19 @@ static int sun6i_dsi_bind(struct device *dev, struct device *master,
 
 	dsi->drv = drv;
 
+	list_for_each_entry(tcon, &drv->tcon_list, list)
+		if (tcon->id == 0)
+			dsi->tcon = tcon;
+
+	if (!dsi->tcon)
+		return -EPROBE_DEFER;
+
+	if (dsi->quirks->use_dsi_irq) {
+		ret = sun6i_dsi_init_irq(dev, dsi);
+		if (ret)
+			return ret;
+	}
+
 	drm_encoder_helper_add(&dsi->encoder,
 			       &sun6i_dsi_enc_helper_funcs);
 	ret = drm_encoder_init(drm,
@@ -980,6 +1102,7 @@ static int sun6i_dsi_probe(struct platform_device *pdev)
 	dsi->dev = dev;
 	dsi->host.ops = &sun6i_dsi_host_ops;
 	dsi->host.dev = dev;
+	dsi->quirks = of_device_get_match_data(dev);
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	base = devm_ioremap_resource(dev, res);
@@ -988,7 +1111,7 @@ static int sun6i_dsi_probe(struct platform_device *pdev)
 		return PTR_ERR(base);
 	}
 
-	dsi->regs = devm_regmap_init_mmio_clk(dev, "bus", base,
+	dsi->regs = devm_regmap_init_mmio(dev, base,
 					      &sun6i_dsi_regmap_config);
 	if (IS_ERR(dsi->regs)) {
 		dev_err(dev, "Couldn't create the DSI encoder regmap\n");
@@ -1007,11 +1130,14 @@ static int sun6i_dsi_probe(struct platform_device *pdev)
 		return PTR_ERR(dsi->mod_clk);
 	}
 
-	/*
-	 * In order to operate properly, that clock seems to be always
-	 * set to 297MHz.
-	 */
-	clk_set_rate_exclusive(dsi->mod_clk, 297000000);
+	dsi->bus_clk = devm_clk_get(dev,"bus");
+	if (IS_ERR(dsi->bus_clk)) {
+		dev_err(dev, "Couldn't get the DSI bus clock\n");
+		return PTR_ERR(dsi->bus_clk);
+	}
+
+	clk_set_rate_exclusive(dsi->mod_clk, dsi->quirks->mod_clk_freq);
+	clk_prepare_enable(dsi->bus_clk);
 
 	dphy_node = of_parse_phandle(dev->of_node, "phys", 0);
 	ret = sun6i_dphy_probe(dsi, dphy_node);
@@ -1056,6 +1182,7 @@ static int sun6i_dsi_remove(struct platform_device *pdev)
 	mipi_dsi_host_unregister(&dsi->host);
 	pm_runtime_disable(dev);
 	sun6i_dphy_remove(dsi);
+	clk_disable_unprepare(dsi->bus_clk);
 	clk_rate_exclusive_put(dsi->mod_clk);
 
 	return 0;
@@ -1106,8 +1233,18 @@ static const struct dev_pm_ops sun6i_dsi_pm_ops = {
 			   NULL)
 };
 
+static const struct sun6i_dsi_quirks sun6i_a31_quirks = {
+	.mod_clk_freq = 297000000,
+};
+
+static const struct sun6i_dsi_quirks sun50i_a64_quirks = {
+	.mod_clk_freq = 148500000,
+	//.use_dsi_irq = true,
+};
+
 static const struct of_device_id sun6i_dsi_of_table[] = {
-	{ .compatible = "allwinner,sun6i-a31-mipi-dsi" },
+	{ .compatible = "allwinner,sun6i-a31-mipi-dsi", .data = &sun6i_a31_quirks },
+	{ .compatible = "allwinner,sun50i-a64-mipi-dsi", .data = &sun50i_a64_quirks },
 	{ }
 };
 MODULE_DEVICE_TABLE(of, sun6i_dsi_of_table);
diff --git a/drivers/gpu/drm/sun4i/sun6i_mipi_dsi.h b/drivers/gpu/drm/sun4i/sun6i_mipi_dsi.h
index dbbc5b3ecbda..cfbbedb99905 100644
--- a/drivers/gpu/drm/sun4i/sun6i_mipi_dsi.h
+++ b/drivers/gpu/drm/sun4i/sun6i_mipi_dsi.h
@@ -14,27 +14,40 @@
 #include <drm/drm_mipi_dsi.h>
 
 struct sun6i_dphy {
-	struct clk		*bus_clk;
-	struct clk		*mod_clk;
-	struct regmap		*regs;
-	struct reset_control	*reset;
+	struct clk			*bus_clk;
+	struct clk			*mod_clk;
+	struct regmap			*regs;
+	struct reset_control		*reset;
+	const struct sun6i_dphy_quirks	*quirks;
+};
+
+struct sun6i_dphy_quirks {
+	bool	has_mod_clk;
 };
 
 struct sun6i_dsi {
-	struct drm_connector	connector;
-	struct drm_encoder	encoder;
-	struct mipi_dsi_host	host;
-
-	struct clk		*bus_clk;
-	struct clk		*mod_clk;
-	struct regmap		*regs;
-	struct reset_control	*reset;
-	struct sun6i_dphy	*dphy;
-
-	struct device		*dev;
-	struct sun4i_drv	*drv;
-	struct mipi_dsi_device	*device;
-	struct drm_panel	*panel;
+	struct drm_connector		connector;
+	struct drm_encoder		encoder;
+	struct mipi_dsi_host		host;
+
+	struct clk			*bus_clk;
+	struct clk			*mod_clk;
+	struct regmap			*regs;
+	struct reset_control		*reset;
+	struct sun6i_dphy		*dphy;
+
+	struct device			*dev;
+	struct sun4i_drv		*drv;
+	struct sun4i_tcon		*tcon;
+	struct mipi_dsi_device		*device;
+	struct drm_panel		*panel;
+
+	const struct sun6i_dsi_quirks	*quirks;
+};
+
+struct sun6i_dsi_quirks {
+	long	mod_clk_freq;
+	bool	use_dsi_irq;
 };
 
 static inline struct sun6i_dsi *host_to_sun6i_dsi(struct mipi_dsi_host *host)
-- 
2.20.1

