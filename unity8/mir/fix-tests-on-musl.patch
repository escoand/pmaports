diff --git a/tests/mir_test/current_thread_name.cpp b/tests/mir_test/current_thread_name.cpp
index 26edf0a708..5073fda648 100644
--- a/tests/mir_test/current_thread_name.cpp
+++ b/tests/mir_test/current_thread_name.cpp
@@ -20,6 +20,51 @@
 
 #include <pthread.h>
 
+#if !defined(__GLIBC__)
+
+#include <errno.h>
+#include <fcntl.h>
+#include <pthreadP.h>
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/prctl.h>
+#include <not-cancel.h>
+int
+pthread_getname_np (pthread_t th, char *buf, size_t len)
+{
+  const struct pthread *pd = (const struct pthread *) th;
+  /* Unfortunately the kernel headers do not export the TASK_COMM_LEN
+     macro.  So we have to define it here.  */
+#define TASK_COMM_LEN 16
+  if (len < TASK_COMM_LEN)
+    return ERANGE;
+  if (pd == THREAD_SELF)
+    return prctl (PR_GET_NAME, buf) ? errno : 0;
+#define FMT "/proc/self/task/%u/comm"
+  char fname[sizeof (FMT) + 8];
+  sprintf (fname, FMT, (unsigned int) pd->tid);
+  int fd = __open64_nocancel (fname, O_RDONLY);
+  if (fd == -1)
+    return errno;
+  int res = 0;
+  ssize_t n = TEMP_FAILURE_RETRY (__read_nocancel (fd, buf, len));
+  if (n < 0)
+    res = errno;
+  else
+    {
+      if (buf[n - 1] == '\n')
+        buf[n - 1] = '\0';
+      else if (n == len)
+        res = ERANGE;
+      else
+        buf[n] = '\0';
+    }
+  __close_nocancel_nostatus (fd);
+  return res;
+}
+#endif
+
 std::string mir::test::current_thread_name()
 {
     static size_t const max_thread_name_size = 16;
